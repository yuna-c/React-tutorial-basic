<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>react</title>
    <link rel="stylesheet" href="./css/reset.css">
</head>
<body>
    <div class="wrap">

        <h1>React</h1>

        <div class="code-info">
            <h2><strong>tutorial</strong></h2>
            <ul class="code-list">
                <li><a href="https://react.vlpt.us/" target="_blank">벨로퍼트와 함께하는 모던 리액트</a></li>
                <li><a href="https://coding-factory.tistory.com/245" target="_blank">git 설치 방법</a></li>
                <li><a href="https://git-scm.com/downloads" target="_blank">git</a></li>
                <li><a href="https://nodejs.org/ko/" target="_blank">node.js(LTS)</a></li>
                <li><a href="https://classic.yarnpkg.com/en/docs/install#windows-stable" target="_blank">yarn</a></li>
                <li><a href="https://code.visualstudio.com/" target="_blank">vsCode</a></li>
                <li><a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=ko" target="_blank">리액트 개발 툴</a></li>
            </ul>
        </div>
        <pre>
            <code>
mac OS의 경우, <a href="https://github.com/nvm-sh/nvm">nvm</a>으로 설치가 가능
터미널 : curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash 설치 후,
껐다가 다시 열어 준 후, 

명령어 : $ nvm install --lts
실행 후 설치

$ node --version
v14.18.0
$ yarn --version
1.22.15
            </code>
        </pre>
        

        <div class="code-info">
            <h2><strong>새 프로젝트 만들어보기</strong></h2>
            <ul class="code-list">
                <li>$ pwd : 현재 폴더 확인</li>
                <li>$ mkdir react-tutorial : 폴더 생성</li>
                <li>$ cd react-tutorial : 폴더 진입</li>
                <li>$ npx create-react-app begin-react : 리액트 생성</li>
                <li>$ ls : 현재 디렉토리에 무엇이 있는지 보여짐</li>
                <li>$ cd begin-react : 폴더 안에 들어감</li>
                <li>$ yarn start || npm start : <a href="http://localhost:3000/" target="_blank">http://localhost:3000/</a> || <a href="http://192.168.0.86:3000/" target="_blank">http://192.168.0.86:3000/</a> 열림</li>
                <li><a href="" target="_blank"></a></li>                                                                                                                  
            </ul>
        </div>
        <pre>
            <code>
// App.js
import React from 'react';
import Hello from './Hello'; //상대경로
// import logo from './logo.svg';
// import './App.css';

function App() {
    return (
    &lt;div&gt;
        &lt;Hello /&gt;
    &lt;/div&gt;
    );
}

export default App;
                
// 컴포넌트(ui 조각) 만들기
import React from 'react'; //리액트 불러와서 사용하겠다고 선언

//컴포넌트 만들기
function Hello() {
    //xml 형태의 값을 리턴 
    return &lt;div&gt;안녕하세요&lt;/div&gt;; //jsx
}

export default Hello; //hello라는 함수를 만들어서 내보내겠다 선언
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>JSX 기본 규칙</strong></h2>
            <ul class="code-list">
                <li><a href="https://babeljs.io/" target="_blank">Babel</a></li>
                <li><b>리액트에서 컴포넌트의 생김새를 정의할 때, 사용하는 문법</b></li>
                <li>태그는 꼭 닫아줘야된다. &lt;div&gt;&lt;/div&gt;</li>
                <li>단독 태그 등록시 Self closing tag를 사용한다. &lt;Hello /&gt;, &lt;input /&gt;, &lt;br /&gt;</li>
                <li>두개 이상의 태그 사용시 &lt;div&gt;&lt;/div&gt; 태그로 감싸줘야한다.</li>
                <li>감싸기 애매한경우 Fragment를 사용하여 &lt;&gt;&lt;&gt; 감싸준다(별도의 태그가 존재하지 않게 뜸).</li>
                <li>JSX를 사용할 때, 코드의 가독성을 위해 return() 괄호안에 써준다.</li>
                <li>내부에서 자바스크립트 값을 사용하는 방법 : {자바스크립트}를 써준다</li>
                <li>style : 인라인 스타일 사용시 객체를 만들어 써준다.</li>
                <li>css class 적용 방법 : className=''</li>
                <li>주석처리 : {/* 주석주석주석 */}</li>
            </ul>
        </div>
        <pre>
            <code>
// 1
import React from 'react';
import Hello from './Hello'; //상대경로
// import logo from './logo.svg';
// import './App.css';

function App() {
    return (
    &lt;div&gt;
        &lt;Hello /&gt;
        &lt;Hello /&gt;
        &lt;Hello /&gt;
        &lt;div>안녕히 계세요&lt;/div&gt;
        &lt;input /&gt;
        &lt;br /&gt;
    &lt;/div&gt;
    );
}

export default App;



// 2 Fragment
import React from 'react';
import Hello from './Hello'; //상대경로
// import logo from './logo.svg';
// import './App.css';

function App() {
  return (
    &lt;&gt;
      &lt;Hello /&gt;
      &lt;div&gt;안녕히 계세요&lt;/div&gt;
    &lt;/&gt;
  );
}

export default App;



// 3 내부에서 자바스크립트 값을 사용하는 방법
import React from 'react';
import Hello from './Hello'; //상대경로
// import logo from './logo.svg';
// import './App.css';

function App() {
  const name = 'react';
  return (
    &lt;&gt;
      &lt;Hello /&gt;
      &lt;div&gt;name&lt;/div&gt;
      &lt;div&gt;{name}&lt;/div&gt;
    &lt;/&gt;
  );
}

export default App;



// 4 inline style
import React from 'react';
import Hello from './Hello'; //상대경로
// import logo from './logo.svg';
// import './App.css';

function App() {
  const name = 'react';
  const style = {
    // camelCase
    backgroundColor : 'black',
    color : 'aqua',
    fontSize : '24',//px
    padding : '1rem'//단위는 '' 안에서 문자열로 넣어주기
  };
  return (
    &lt;&gt;
      &lt;Hello /&gt; 
      &lt;div style={style}&gt;name&lt;/div&gt;
      &lt;div&gt;{name}&lt;/div&gt;
    &lt;/&gt;
  );
}

export default App;


// 5 css 적용
import React from 'react';
import Hello from './Hello'; //상대경로
import './App.css' //css 첨부 경로

function App() {
  const name = 'react';
  const style = {
    // camelCase
    backgroundColor : 'black',
    color : 'aqua',
    fontSize : '24',//px
    padding : '1rem'//단위는 '' 안에서 문자열로 넣어주기
  };
  return (
    &lt;&gt;
      &lt;Hello /&gt; 
      &lt;div className="gray-box" style={style}&gt;name&lt;/div&gt;
      &lt;div&gt;{name}&lt;/div&gt;
    &lt;/&gt;
  );
}

export default App;



// 6 주석
import React from 'react';
import Hello from './Hello'; //상대경로
import './App.css' //css 첨부 경로

function App() {
  const name = 'react';
  const style = {
    // camelCase
    backgroundColor : 'black',
    color : 'aqua',
    fontSize : '24',//px
    padding : '1rem'//단위는 '' 안에서 문자열로 넣어주기
  };
  return (
    &lt;&gt;
    &lt;Hello 
        //이런식으로 작성하는 주석도 있다
      /&gt; {/* hello 컴포넌트 불러오기 */}
      &lt;div style={style}&gt;name&lt;/div&gt;
      &lt;div className="gray-box"&gt;{name}&lt;/div&gt;
    &lt;/&gt;
  );
}

export default App;

            </code>
        </pre>

        <div class="code-info">
            <h2><strong>props를 통해 컴포넌트에게 값 전달하기</strong></h2>
            <ul class="code-list">
                <li>properties</li>
                <li>특정 값을 전달해 줄 때 사용</li>
                <li>
                    <div class="img-box">
                        <img src="https://raw.githubusercontent.com/yuna-c/react/master/img/props.PNG" alt="">
                    </div>
                </li>
                <li>{{}} => 객체를 감싸는 중괄호</li>
                <li>props : 넣어준 값들이 객체형태로 들어가 있다.</li>
                <li>
                    props를 설정하지 않았을 떄 기본적인 값들을 사용하는 방법 : <br>
                    Hello.defaultProps = {<br>
                        name : '이름없음' <br>
                    }                    
                </li>
                <li>props Children : div가 아니고 어떠한 compenent 일 때, Wrapper 안에 넣는 값을 조회하는것</li>
            </ul>
        </div>
        <pre>
            <code>
// 1
import React from 'react';
import Hello from './Hello'; 

function App() {
  return (
    &lt;Hello name="react" /&gt;
  );
}

export default App;


import React from 'react'; 

function Hello(props) {
    console.log(props);
    return &lt;div&gt;안녕하세요 {props.name}&lt;/div&gt;; 
}

export default Hello; 



// 2 props : 넣어준 값들이 객체형태로 들어가 있다
import React from 'react';
import Hello from './Hello'; 

function App() {
  return (
    &lt;Hello name="react" color="red" /&gt;
  );
}

export default App;


import React from 'react'; 

function Hello(props) {
    console.log(props);
    return &lt;div style={{
        color : props.color
    }}&gt; 안녕하세요 {props.name}&lt;/div&gt;; 
}

export default Hello; 



// 3 구조분해 형식으로 코드를 간단하게 할 수 있다
import React from 'react'; 

function Hello({ color, name }) { //구조분해
    console.log(props);
    return &lt;div style={{
        color
    }}&gt; 안녕하세요 {name}&lt;/div&gt;; 
}

export default Hello; 



// 4 기본적으로 사용할 값을 사용하는 방법 
import React from 'react';
import Hello from './Hello'; 

function App() {
  return (
    &lt;&gt;
      &lt;Hello name="react" color="red" /&gt;
      &lt;Hello color="pink" /&gt;
    &lt;/&gt;
  );
}

export default App;


import React from 'react'; 

function Hello({ color, name }) { //구조분해 : 파라미터로 받아올 수 있다. 비구조화 해서 추출 가능
    return &lt;div style={{
        color
    }}&gt; 안녕하세요 {name}&lt;/div&gt;; 
}

Hello.defaultProps = {
    name : '이름없음' 
}

export default Hello; 



// 5 props Children
import React from 'react';
import Wrapper from './Wrapper';
import Hello from './Hello'; 

function App() {
  return (
    &lt;Wrapper&gt;
      &lt;Hello name="react" color="red" &gt;
      &lt;Hello color="pink" &gt;
    &lt;/Wrapper&gt;
  );
}

export default App;


import React from 'react';
{/* &lt;Wrapper&gt;dfajffghfd3rfjdfjdclk&lt;/Wrapper&gt; */}
// div가 아니고 어떠한 compenent 일 때, Wrapper 안에 넣는 값을 조회하는것이 propsChildren

function Wrapper({ children }){ // 밖으로 추출
    const style = {
        border : '2px solid black',
        padding : 16
    };

    return &lt;div style={style}&gt;{children}&lt;/div&gt;
}

export default Wrapper;

            </code>
        </pre>

        <div class="code-info">
            <h2><strong>조건부 랜더링</strong></h2>
            <ul class="code-list">
                <li>특정 조건이 참인지 거짓인지에 따라서 다른 결과를 보여주는 것</li>
                <li>isSpecial={true} => isSpecial</li>
                <li>삼항 연산자 : {isSpecial ? '스페셜하다!' :  '낫스페셜'}, 값이 바뀔때</li>
                <li>and 연산자 : {isSpecial && <b>*</b>}, 무언가를 숨길 때</li>
                <li><a href="tutorial\begin-react\src\Hello.js" target="_blank">props</a></li>
                <li><a href="tutorial\begin-react\src\Hello.js" target="_blank">비구조화 할당, 구조분해</a></li>
                <li><a href="tutorial\begin-react\src\Wrapper.js" target="_blank">props.children</a></li>
                <li><a href="tutorial\begin-react\src\IfIf.js" target="_blank">true/false</a></li>
            </ul>
        </div>
        <pre>
            <code>
// 1 true/ false
import React from 'react';
import Wrapper from './Wrapper';
import Hello from './Hello'; 

function App() {
  return (
    &lt;Wrapper&gt;
      &lt;Hello name="react" color="red" isSpecial={true} /&gt;
      &lt;Hello color="pink" /&gt;
    &lt;/Wrapper&gt;
  );
}

export default App;


import React from 'react'; 

function Hello({ color, name, isSpecial }) { //삼항 연산자 사용해 true/false일떄의 다른 값 추출
    return (
        &lt;div style={{
            color
        }}>&gt;
        {/* {isSpecial ? &lt;b&gt;*&lt;/b&gt; : null}  */}
        {/* isSpecial값이 트루면 *표시 아니면 null */}
        {isSpecial && &lt;b&gt;*&lt;/b&gt;} 
        {/* and 연산자가 더 편함, isSpecial = false일때, 저 and 연산자가 false가 되기때문에 출력이 안됨, true일때는 뒤에 나타나는 값이 결과가 되기 때문에 출력 */}
        {/* null, undefined, false 같은 값은 표현이 안되는데, false인 값의 0 이라는 숫자는 표시가 됨 */}
       
            안녕하세요 {name}
        &lt;/div&gt;
    ); 
}

Hello.defaultProps = {
    name : '이름없음' 
}

export default Hello; 

import React from 'react'; 

function Hello({ color, name, isSpecial }) { //삼항 연산자 사용해 true/false일떄의 다른 값 추출
    return (
        &lt;div style={{
            color
        }}&gt;
        {/* {isSpecial ? &lt;b>*&lt;/b&gt; : null}  */}
        {/* isSpecial값이 트루면 *표시 아니면 null */}
        &lt;b&gt;{isSpecial ? '스페셜하다!' :  '낫스페셜'}&lt;/b&gt;
        {/* {isSpecial && &lt;b&gt;*&lt;/b&gt;}  */} //숨길때 편함
        {/* and 연산자가 더 편함, isSpecial = false일때, 저 and 연산자가 false가 되기때문에 출력이 안됨, true일때는 뒤에 나타나는 값이 결과가 되기 때문에 출력 */}
        {/* null, undefined, false 같은 값은 표현이 안되는데, false인 값의 0 이라는 숫자는 표시가 됨 */}
       
            안녕하세요 {name}
            &lt;/div&gt;
    ); 
}

Hello.defaultProps = {
    name : '이름없음' 
}

export default Hello; 


            </code>
        </pre>

        <div class="code-info">
            <h2><strong>useState 를 통한 동적 상태 관리(hooks)</strong></h2>
            <ul class="code-list">
                <li>컴포넌트에서 보여져야하는 내용이 사용자 인터렉션에 따라 달라질 때 구현하는법</li>
                <li>useState : 기본값을 바꾸는 함수</li>
                <li>setNumber : 1. 다음 상태 2. 이런 로직으로 업데이트 할거라는 함수</li>
                <li><a href="tutorial\begin-react\src\Counter.js"  target="_blank">counter</a></li>
            </ul>
        </div>
        <pre>
            <code>
// 1 useState 를 통한 바뀌는 값 관리
import React, { useState } from 'react'; //useState  => 리액트에서 useState라는 함수를 가져옴

function Counter() {
    const [number, setNumber] = useState(0); //useState(0) 배열을 반환
    // number라는 상태를 만들건데, 이 상태의 기본 값을 0으로 하겠다, setNumber는 기본 값을 바꿔주는 값이다.

    // 원래 이렇게 진행이 되야되는데, 배열 비구조화 할당을 통해 위의 형태로 표시
    // const numberState = uesState(0);
    // const number = numberState[0]; //첫번째 원소
    // const setNumber = numberState[1]; //두번째 원소

    const onIncrease = () => {
      //number을 0으로 만들고, setNumber을 이상태로 바꾸어주는 것
      // setNumber(number + 1);
      // 어떻게 업데이트 할 지의 대한 로직을 정의하는 함수를 넣어줄 수도 있다. (최적화와 관련이 있음)
      setNumber(prevNumber => prevNumber + 1); //업데이트 함수
    }
    const onDecrease = () => {
      //setNumber(number - 1)
      setNumber(prevNumber => prevNumber - 1);
    }
    return (
        &lt;div&gt;
            &lt;h1&gt;{number}</h1>
            {/* 함수를 넣어주는거지 함수를 호출()해 주는 게 아님 */}
            &lt;button onClick={onIncrease}&gt;+1&lt;/button&gt;
            &lt;button onClick={onDecrease}&gt;-1&lt;/button&gt;
          &lt;/div&gt;
    )
}
export default Counter;
            </code>
        </pre>

        <div class="code-info">
          <h2><strong>리액트에서 input 상태 관리하기</strong></h2>
          <ul class="code-list">
              <li>초기화 기능있는 input 상태창(문자열 관리)</li>
              <li>여러개의 input 상태 관리하기(name) <br>
                ({
                //객체 업데이트 
                name : '',
                nickname : '',  <br>
                객체 상태를 업데이트 할때는 ...spread 문법으로 가지고온다
            });</li>
            <li><a href="tutorial\begin-react\src\InputSample.js" target="_blank">input 관리하기</a></li>
            <li><a href="tutorial\begin-react\src\InputSample2.js" target="_blank">여러개의 input 관리하기</a></li>
          </ul>
      </div>
      <pre>
          <code>
// 1 인풋창 값 받아오기, 초기화
import React,{ useState } from 'react';

function InputSample() {
    //input 값을 확인할 상태를 만들어 준다
    const [text, setText] = useState('');// 기본값 공백
    const onChange = (e) => { // input event 내용이 파라미터로 들어와 사용할 수 있게 되는 것 
        setText(e.target.value);
    }

    // 초기화 기능
    const onReset = () => {
        setText(''); 
    }
    return (
        &lt;div&gt;
            &lt;input onChange={onChange} value={text} /&gt;
            &lt;button onClick={onReset}&gt;초기화&lt;/button&gt;
            &lt;div&gt;
                &lt;b&gt;값 : &lt;/b&gt;
                {text}
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

export default InputSample;

import React from 'react';
import InputSample from './InputSample';

function App() {
  return (
    &lt;&gt;
      &lt;InputSample onChange/&gt;
    &lt;/&gt;
   
  );
}

export default App;


// 2 인풋 여러개 일 때 
import React,{ useState } from 'react';

function InputSample() {
    const [inputs, setInputs] = useState({
        //객체 업데이트 
        name : '',
        nickname : '',  
    });
    const { name, nickname } = inputs; //정보들을 참고해서 객체를 업데이트 해준다
    const onChange = (e) => { 
        const { name, value } = e.target; //추출

        // const nextInputs = { //기존의 객체 복사(새로운 객체를 새로운 상태로 쓰곘다)
        //     ...inputs,// spread 문법
        //     [name] : value,
        // }
        
        // 특정 값 덮어씌우기 
        //nextInputs[name] = value;
        
        // console.log(e.target.name);
        // console.log(e.target.value);

        //새로운 객체 만들고 불변성을 지킨다
        setInputs({
            ...inputs,// spread 문법
            [name] : value,
        });
        
    };

    const onReset = () => {
        setInputs({
            name : '',
            nickname : '',
        });
    };
    return (
        &lt;div&gt;
            &lt;input 
                name="name" 
                placeholder="이름" 
                onChange={onChange} 
                value={name} 
            /&gt;
            &lt;input 
                name="nickname" 
                placeholder="닉네임" 
                onChange={onChange} 
                value={nickname} 
            /&gt;
            &lt;button onClick={onReset}&gt;초기화&lt;/button&gt;
            &lt;div&gt;
                &lt;b&gt;값 : &lt;/b&gt;
                {name}({nickname})
            &lt;/div&gt;
        &lt;/div&gt;
    );
}

export default InputSample;

          </code>
      </pre>

      <div class="code-info">
        <h2><strong>useRef로 특정 DOM 선택하기</strong></h2>
        <ul class="code-list">
            <li>getElementById, querySelector 같은 돔 셀렉터 함수로 돔을 선택할 때와 같이 리액트에서도 dom을 직접 선택할 때가 있는데, 특정 ele의 크기와 위치, scroll, focus, video같은 라이브러리 사용, d3,chart.js 그래프관련 라이브러리 사용할 때 ref라는 것을 사용</li>
            <li>ref : 특정 돔을 선택할 때 사용하는 hooks</li>
            <li>useRef : 함수형 컴포넌트에서 hookref를 사용, 랜더링과 관계없는 변수를 관리할 때도 사용됨</li>
            <li>useRef : 상태를 바꾸면 컴포넌트가 리 랜더링됨</li>
            <li>React.createRef(), callback함수 : class형 컴포넌트에서 사용</li>
            <li><a href="tutorial\begin-react\src\UseRef.js" target="_blank">돔에 직접 접근하는 방법</a></li>
        </ul>
    </div>
    <pre>
        <code>
// useRef
import React,{ useState, useRef } from 'react';
// 돔에 직접 접근하는
function InputSample() {
    const [inputs, setInputs] = useState({
        //객체 업데이트 
        name : '',
        nickname : '',  
    });
    // use 객체 만들기
    const nameInput = useRef();
    
    const { name, nickname } = inputs; 
    const onChange = (e) => { 
        const { name, value } = e.target; 

        setInputs({
            ...inputs,
            [name] : value,
        });
    };

    const onReset = () => {
        setInputs({
            name : '',
            nickname : '',
        });
        //current Dom 객체 가져오기
        nameInput.current.focus();
    };
    return (
        &lt;div&gt;
            &lt;input 
                name="name" 
                placeholder="이름" 
                onChange={onChange} 
                value={name} 
                ref={nameInput}
            /&gt;
            &lt;input 
                name="nickname" 
                placeholder="닉네임" 
                onChange={onChange} 
                value={nickname} 
            /&gt;
            &lt;button onClick={onReset}&gt;초기화&lt;/button&gt;
            &lt;div&gt;
              &lt;b&gt;값 : &lt;/b&gt;
                {name}({nickname})
            &lt;/div&gt;
          &lt;/div&gt;
    );
}

export default InputSample;
        </code>
    </pre>

    <div class="code-info">
      <h2><strong>배열 랜더링하기</strong></h2>
      <ul class="code-list">
          <li>배열의 이름이 바뀔 때 : map 사용 </li>
          <li>map이라는 함수를 사용해서 객체배열형태를 컴포넌트 배열 형태로 변환</li>
          <li>key가 없으면 기존의 값을 모두 지우고 새로운 형태가 들어오기 때문에 필수, index로 잘 쓰지는 않는다</li>
          <li><a href="tutorial\begin-react\src\UserList.js" target="_blank">배열 랜더링</a></li>
          <li><a href="tutorial\begin-react\src\UserList2.js" target="_blank">효율적인 배열 랜더링</a></li>
          <li><a href="tutorial\begin-react\src\UserList3.js" target="_blank">map과 key</a></li>
          <li>
            key :<br>
            const array = [a, b, c, d]; 배열이 있을 때, <br> 
            array.map(item => &lt;div>&gt;item}&lt;/div&gt;) div엘리먼트들로 변환을 할 때<br>
            key가 없다면 b,c 사이에 z라는 값을 넣을 때, c가 z로 바뀌고 d가 c로 바뀌고 새로운d가 생긴다.<br>
            but key={1}가 있다면 정확히 어떤 객체를 가르키는지 알기 때문에 사이에 id가 5인 z가 생겼을때 B와 C사이에 z가 생김
          </li>
      </ul>
    </div>
    <pre>
      <code>
// 배열 가지고오기
import React from 'react';

//새로운 컴포넌트 만들기
function User({ user }){
    return (
        &lt;div&gt;
          &lt;b&gt;{user.username}&lt;/b&gt; &lt;span&gt;({user.email})&lt;/span&gt;
        &lt;/div&gt;
    );
}

function UserList() {
    const users = [
        {
            id: 1,
            username: 'velopert',
            email: 'public.velopert@gmail.com'
        },
        {
            id: 2,
            username: 'tester',
            email: 'tester@example.com'
        },
        {
            id: 3,
            username: 'liz',
            email: 'liz@example.com'
        }
    ];

    return (
        &lt;div&gt;
           &lt;User user={users[0]}/&gt;
           &lt;User user={users[1]}/&gt;
           &lt;User user={users[2]}/&gt;
        &lt;/div&gt;
    )
};

export default UserList;



import React from 'react';
import UserList from './UserList';

function App() {
  return (
    &lt;&gt;
      &lt;UserList /&gt;
    &lt;/&gt;
   
  );
}

export default App;


// map 사용
import React from 'react';

//새로운 컴포넌트 만들기
function User({ user }){
    return (
        &lt;div&gt;
            &lt;b&gt;{user.username}&lt;/b&gt; &lt;span&gt;({user.email})&lt;/span&gt;
        &lt;/div&gt;
    );
}

function UserList() {
    const users = [
        {
            id: 1, //아이디 값을 키로 설정해 줘야함
            username: 'velopert',
            email: 'public.velopert@gmail.com'
        },
        {
            id: 2,
            username: 'tester',
            email: 'tester@example.com'
        },
        {
            id: 3,
            username: 'liz',
            email: 'liz@example.com'
        }
    ];

    return (
        &lt;div&gt;
            {
                users.map(
                    user => (&lt;User user={user} key={user.id} /&gt;)
                )
            }
        &lt;/div&gt;
    )
};

export default UserList;

s
import React from 'react';
import UserList from './UserListMap';

function App() {
  return (
    &lt;&gt;
      &lt;UserList /&gt;
    &lt;/&gt;
   
  );
}

export default App;



// map과 고유key
import React from 'react';
//user map
function User({ user }) {
    return (
        &lt;div&gt;
            &lt;b&gt;
                {/* {users[0].username} */}
                {user.username}
            &lt;/b&gt;
            &lt;span&gt;
                ({user.email})
            &lt;/span&gt;
        &lt;/div&gt;
    );
};


function UserList3() {
    //효율적인 방법
    const users = [
        {
            id : 1,
            username : 'velopert',
            email : 'public.vepopert@gmail.com'
        },
        {
            id : 2,
            username : 'tester',
            email : 'tester@example.com'
        },
        {
            id : 3,
            username : 'liz',
            email : 'liz@example.com'
        }
    ];

    return (
        &lt;div&gt;
           {/* &lt;User user={users[0]} /&gt;
           &lt;User user={users[1]} /&gt;
           &lt;User user={users[2]} /&gt; */}
           {
               users.map(
                   // user => (&lt;User user={user} key={user.id} /&gt;)
                   // key 라는 props는 각 원소들마다 고유값을 주는 것
                   // 고유 값이 없을 때는?? 두번째 파라미터의 index값을 사용해도 됨
                   (user, index) => (&lt;User user={user} key={index} /&gt;)
                )
           }
        &lt;/div&gt;
    )
};

export default UserList3;

      </code>
    </pre>

    <div class="code-info">
        <h2><strong>UseRef로 컴포넌트 안의 변수 만들기</strong></h2>
        <ul class="code-list">
            <li>useRef : 컴포넌트가 리랜더링 될때마다, 기억할 수 있는 값 관리할 때도 사용</li>
            <li>관리하는 값 : setTimeout, setInterval의 id값을 기억할 때, 외부 라이브러리를 사용하여 생성된 인스턴스를 담을 때, scroll위치를 기억할 때 등등</li>
            <li>UseRef는 값이 바뀌어도 컴포넌트가 리랜더링 되지 않는다</li>
            <li><a href="\tutorial\begin-react\src\UserList4.js" target="_blank">변수 만들기</a></li>
        </ul>
    </div>
    <pre>
        <code>
import React from 'react';
//user map
function User({ user }) {
    return (
        &lt;div&gt;
            &lt;b&gt;
                {/* {users[0].username} */}
                {user.username}
            &lt;/b&gt;
            &lt;span&gt;
                ({user.email})
            &lt;/span&gt;
        &lt;/div&gt;
    );
};


function UserList4({ users }) {
    //user를 props로 받아오게끔
    

    return (
        &lt;div&gt;
            {
                users.map(
                    (user, index) => (&lt;User user={user} key={index} /&gt;)
            )
            }
        &lt;/div&gt;
    )
};

export default UserList4;


// app.js
import React, { useRef } from 'react';

import UserList4 from './UserList4';

function App() {

  const users = [
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com'
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com'
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com'
    }
  ];

  const nextId = useRef(4);
  // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
  const onCreate = () => {
    console.log(nextId.current); // 4
    nextId.current += 1;
  };
  return (
    &lt;&gt;
        &lt;UserList4 users={users} /&gt;
    &lt;/&gt;
   
  );
}

export default App;

        </code>
    </pre>

    <div class="code-info">
        <h2><strong>배열에 항목 추가하기</strong></h2>
        <ul class="code-list">
            <li>spread 연산자, concat을 써서 항목을 마지막에 추가한다.</li>
            <li><a href="\tutorial\begin-react\src\CreateUser.js" target="_blank">항목 추가</a></li>
        </ul>
    </div>
    <pre>
        <code>
import React from 'react';

function CreateUser({ username, email, onChange, onCreate }) {

    return (
        &lt;div&gt;
            &lt;input 
                name="username" 
                placeholder="계정명" 
                onChange={onChange} 
                value={username}
            /&gt;
            &lt;input 
                name="email" 
                placeholder="이메일" 
                onChange={onChange} 
                value={email}
            /&gt;
            &lt;button onClick={onCreate}&gt;등록&lt;/button&gt;
        &lt;/div&gt;
    )
};

export default CreateUser;


//app.js
import React, { useRef, useState } from 'react';
import UserList4 from './UserList4';
import CreateUser from './CreateUser';

function App() {
  //createUser에서 필요한 props 준비
  const [inputs, setInputs] = useState({
    username : '',
    email : '',
  });

  const { username, email } = inputs;
  const onChange = (e) => {
    const { name, value } = e.target;
    setInputs({
      ...inputs,
      [name] : value
    });
  };

  // 배열을 컴포넌트의 상태로 관리해주는법 
  const [users, setUsers] = useState([
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com'
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com'
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com'
    }
  ]);


  const nextId = useRef(4);
  
  // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
  const onCreate = () => {
    //push splice sort 사용 X
    // 배열의 불변성 지키면서 새로운 항목 추가하는 법
    // 1.배열에서 spread 연산자 쓰기
    // 새로운 user 객체 만들기
    const user = {
      id : nextId.current,
      username,
      email,
    }; 
    setUsers(
      [...users, user] //spread
    ); 
    setUsers(
      // [...users, user] spread
      users.concat(user) //concat 함수
    ); //기존 배열 복사해서 넣으면서 새항목 추가
    // 2. concat함수 쓰기
    setInputs({
      username : '',
      email : ''
    });
    console.log(nextId.current); // 4
    nextId.current += 1;
  };


  return (
    &lt;&gt;
        &lt;CreateUser 
            username={username} 
            email={email} 
            onChange={onChange} 
            onCreate={onCreate}
        /&gt;
    &lt;UserList4 users={users} /&gt;
    </>
   
  );
}

export default App;

        </code>
    </pre>

    <div class="code-info">
        <h2><strong>배열의 항목 제거하기</strong></h2>
        <ul class="code-list">
            <li>함수를 호출하는게 아니라 ()=>{onRemove(id)} 함수를 넣어줘야한다(전체삭제가 아니라 부분삭제기 때문)</li>
            <li><a href="\tutorial\begin-react\src\UserList4.js" target="_blank">항목 제거</a></li>
        </ul>
    </div>
    <pre>
        <code>
import React from 'react';
//user map
function User({ user, onRemove }) { //onRemove 받아오기
    //추출
    const { username, email, id } = user;
    return (
         &lt;div&gt;
            &lt;b&gt;
                {/* {users[0].username} */}
                {/* {user.username} */}
                {username}
            &lt;/b&gt;
            &lt;span&gt;
                ({email})
            &lt;/span&gt;
            &lt;button onClick={()=>onRemove(id)}>&gt;
            {/* 함수를 새로 만들어서 호출 */}
                {/* 버튼이 눌렀을때는 prop를 id값을 넣어서 호출할꺼다 */}
                삭제 
            &lt;/button&gt;
        &lt;/div&gt;
    );
};


function UserList4({ users, onRemove }) {//삭제하는 props
    //user를 props로 받아오게끔
    return (
        &lt;div&gt;
            {
                users.map(
                    (user, index) =&gt; (
                        &lt;User user={user} 
                        key={user.id} 
                        onRemove={onRemove} 
                    /&gt;
                )
            )
            }
        &lt;/div&gt;
    )
};

export default UserList4;


// app.js
import React, { useRef, useState } from 'react';

import UserList4 from './UserList4';
import CreateUser from './CreateUser';

function App() {
  //createUser에서 필요한 props 준비
  const [inputs, setInputs] = useState({
    username : '',
    email : '',
  });

  const { username, email } = inputs;
  const onChange = (e) => {
    const { name, value } = e.target;
    setInputs({
      ...inputs,
      [name] : value
    });
  };

  // 배열을 컴포넌트의 상태로 관리해주는법 
  const [users, setUsers] = useState([
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com'
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com'
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com'
    }
  ]);




  const nextId = useRef(4);
  
  // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
  const onCreate = () => {
    //push splice sort 사용 X
    // 배열의 불변성 지키면서 새로운 항목 추가하는 법
    // 1.배열에서 spread 연산자 쓰기
    // 새로운 user 객체 만들기
    const user = {
      id : nextId.current,
      username,
      email,
    }; 
    setUsers(
      [...users, user] //spread
    ); 
    setUsers(
      // [...users, user] spread
      users.concat(user) //concat 함수
    ); //기존 배열 복사해서 넣으면서 새항목 추가
    // 2. concat함수 쓰기
    setInputs({
      username : '',
      email : ''
    });
    console.log(nextId.current); // 4
    nextId.current += 1;
  };


  // remove
  const onRemove = id => { //파라미터로 받아온 아이디랑 비교
    setUsers(users.filter(user => user.id !== id));
  };


  return (
    &lt;&gt; 
      &lt;CreateUser 
        username={username} 
        email={email} 
        onChange={onChange} 
        onCreate={onCreate}
      /&gt;
      &lt;UserList4 
        users={users} 
        onRemove={onRemove} 
      /&gt;
    &lt;/&gt;
   
  );
}

export default App;

        </code>
    </pre>

    <div class="code-info">
        <h2><strong>배열에 항목 수정하기</strong></h2>
        <ul class="code-list">
            <li><a href="\tutorial\begin-react\src\UserList5.js" target="_blank">항목 수정</a></li>
        </ul>
    </div>
    <pre>
        <code>
import React from 'react';
//user map
function User({ user, onRemove, onToggle }) { //onRemove 받아오기
    //추출
    const { username, email, id, active } = user;
    return (
        &lt;div&gt;
            &lt;b style={{
                    color : active ? 'green' : 'black',
                    cursor : 'pointer'
                }}
                onClick={() =&gt;onToggle(id)}
            &gt;
                {username}
            &lt;/b&gt;
            &nbsp;
            &lt;span&gt;
                ({email})
            &lt;/span&gt;
            &lt;button onClick={()=&gt;onRemove(id)}>&gt;
            {/* 함수를 새로 만들어서 호출 */}
                {/* 버튼이 눌렀을때는 prop를 id값을 넣어서 호출할꺼다 */}
                삭제 
            &lt;/button&gt;
        &lt;/div&gt;
    );
};


function UserList5({ users, onRemove, onToggle }) {//삭제하는 props
    //user를 props로 받아오게끔
    return (
        &lt;div&gt;
            {
                users.map(
                    (user, index) =&gt; (
                        &lt;User user={user} 
                        key={user.id} 
                        onRemove={onRemove} 
                        onToggle={onToggle}
                    /&gt;
                )
            )
            }
        &lt;/div&gt;
    )
};

export default UserList5;


//app.js
import React, { useRef, useState } from 'react';
import UserList5 from './UserList5';
import CreateUser from './CreateUser';

function App() {
  //createUser에서 필요한 props 준비
  const [inputs, setInputs] = useState({
    username : '',
    email : '',
  });

  const { username, email } = inputs;
  const onChange = (e) => {
    const { name, value } = e.target;
    setInputs({
      ...inputs,
      [name] : value
    });
  };

  // 배열을 컴포넌트의 상태로 관리해주는법 
  const [users, setUsers] = useState([
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com',
        active : true,
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com',
        active : false,
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com',
        active : false,
    }
  ]);




  const nextId = useRef(4);
  
  // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
  const onCreate = () => {
    //push splice sort 사용 X
    // 배열의 불변성 지키면서 새로운 항목 추가하는 법
    // 1.배열에서 spread 연산자 쓰기
    // 새로운 user 객체 만들기
    const user = {
      id : nextId.current,
      username,
      email,
    }; 
    setUsers(
      [...users, user] //spread
    ); 
    setUsers(
      // [...users, user] spread
      users.concat(user) //concat 함수
    ); //기존 배열 복사해서 넣으면서 새항목 추가
    // 2. concat함수 쓰기
    setInputs({
      username : '',
      email : ''
    });
    console.log(nextId.current); // 4
    nextId.current += 1;
  };


  // remove
  const onRemove = id => { //파라미터로 받아온 아이디랑 비교
    setUsers(users.filter(user => user.id !== id));
  };

  // onToggle : 유저가 가지고 있던 값을 가져오고, 특정 값을 덮어 씌우는 방법
  const onToggle = id => {
    //불변성 지키면서 배열 업데이트 할 때, map 사용
    setUsers(users.map(
      user => user.id === id 
      ? { ...user, active : !user.active }
      : user
    ));
  };

  return (
    &lt;&gt;
        &lt;CreateUser 
            username={username} 
            email={email} 
            onChange={onChange} 
            onCreate={onCreate}
        /&gt;

       &lt;UserList5 
            users={users} 
            onRemove={onRemove} 
            onToggle={onToggle}
      /&gt;
    &lt;/&gt;
   
  );
}

export default App;

        </code>
    </pre>

    <div class="code-info">
        <h2><strong>useEffect Hook</strong></h2>
        <ul class="code-list">
            <li>리액트 컴퍼넌트가 처음에 화면에 나타나고, 사라지게 될 때, 특정 작업을 할 수 있게 한다.</li>
            <li>props나 상태가 바뀌어 업데이트 될 때, 리랜더링 될때도 사용됨</li>
            <li>{ useEffect } 불러오기</li>
            <li>mount : 나타난것, onmout : 사라지는것</li>
            <li>마운트 될 때 추가하는 작업 : props => state 설정, REST API, D3 Video.js 사용시, setInterval, setTimeout</li>
            <li>언마운트 될 때 추가하는 작업 : clearInterval, clearTimeout, 라이브러리 인스턴스 제거</li>
            <li> useEffect(() => { }, [deps]) 에서 등록하는 함수는 특정값이 업데이트된 직후 실행이됨</li>
            <li><a href="\tutorial\begin-react\src\app.js" target="_blank">컴포넌트 제어</a></li>
        </ul>
    </div>
    <pre>
        <code>
import React, { useEffect } from 'react';
//user map
function User({ user, onRemove, onToggle }) { //onRemove 받아오기
    //추출
    const { username, email, id, active } = user;
    // 첫번째 파라미터 = 실행하고픈 함수, deps
    /*
    useEffect(() => {
        console.log('컴포넌트가 화면에 나타납니다.');
        // 마운트 될 때 추가하는작업
        // props => state 설정
        // REST API
        // D3 Video.js 사용시
        // setInterval, setTimeout
        return () => {
            console.log('컴포넌트가 화면에서 사라졌습니다.');
            // 언마운트 될 때 추가하는 작업 
            // clearInterval, clearTimeout
            // 라이브러리 인스턴스 제거
        }
    }, []);// 배열 deps(props, 상태)
    */
    /* 
    useEffect(() => { //마운트 될때도 user값이 나타남
        console.log('user값이 설정됨');
        console.log(user);
        return () => {// 뒷정리 함수
            console.log('user값이 바뀌기 전');
            console.log(user);
        }
    }, [user]);
    */
    useEffect(() => { //하나를 눌러도 모든 컴포넌트에서 호출됨
        console.log(user);
    })
    /* 실 사용 예시
    useEffect(() => {
        loadPost(username, urlSlug);
    }, [username, urlSlug]);
    */
    return (
        &lt;div&gt;
            &lt;b style={{
                    color : active ? 'green' : 'black',
                    cursor : 'pointer'
                }}
                onClick={() =>onToggle(id)}
            &gt;
                {/* {users[0].username} */}
                {/* {user.username} */}
                {username}
            &lt;/b&gt;
            &nbsp;
            &lt;span&gt;
                ({email})
            &lt;/span&gt;
            &lt;button onClick={()=&gt;onRemove(id)}>&gt;
            {/* 함수를 새로 만들어서 호출 */}
                {/* 버튼이 눌렀을때는 prop를 id값을 넣어서 호출할꺼다 */}
                삭제 
            &lt;/button&gt;
        &lt;/div&gt;
    );
};


function UserList5({ users, onRemove, onToggle }) {//삭제하는 props
    //user를 props로 받아오게끔
    return (
        &lt;div&gt;
            {
                users.map(
                    (user, index) => (
                        &lt;User user={user} 
                        key={user.id} 
                        onRemove={onRemove} 
                        onToggle={onToggle}
                    /&gt;
                )
            )
            }
        &lt;/div&gt;
    )
};

export default UserList5;


// app.js
import React, { useRef, useState } from 'react';
import UserList5 from './UserList5';
import CreateUser from './CreateUser';

function App() {
  //createUser에서 필요한 props 준비
  const [inputs, setInputs] = useState({
    username : '',
    email : '',
  });

  const { username, email } = inputs;
  const onChange = (e) => {
    const { name, value } = e.target;
    setInputs({
      ...inputs,
      [name] : value
    });
  };

  // 배열을 컴포넌트의 상태로 관리해주는법 
  const [users, setUsers] = useState([
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com',
        active : true,
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com',
        active : false,
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com',
        active : false,
    }
  ]);


  const nextId = useRef(4);
  
  // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
  const onCreate = () => {
    //push splice sort 사용 X
    // 배열의 불변성 지키면서 새로운 항목 추가하는 법
    // 1.배열에서 spread 연산자 쓰기
    // 새로운 user 객체 만들기
    const user = {
      id : nextId.current,
      username,
      email,
    }; 
    setUsers(
      [...users, user] //spread
    ); 
    setUsers(
      // [...users, user] spread
      users.concat(user) //concat 함수
    ); //기존 배열 복사해서 넣으면서 새항목 추가
    // 2. concat함수 쓰기
    setInputs({
      username : '',
      email : ''
    });
    console.log(nextId.current); // 4
    nextId.current += 1;
  };


  // remove
  const onRemove = id => { //파라미터로 받아온 아이디랑 비교
    setUsers(users.filter(user => user.id !== id));
  };

  // onToggle : 유저가 가지고 있던 값을 가져오고, 특정 값을 덮어 씌우는 방법
  const onToggle = id => {
    //불변성 지키면서 배열 업데이트 할 때, map 사용
    setUsers(users.map(
      user => user.id === id 
      ? { ...user, active : !user.active }
      : user
    ));
  };


  return (
    &lt;&gt;
        &lt;CreateUser 
            username={username} 
            email={email} 
            onChange={onChange} 
            onCreate={onCreate}
        /&gt;

       &lt;UserList5 
            users={users} 
            onRemove={onRemove} 
            onToggle={onToggle}
      /&gt;
    &lt;/&gt;
   
  );
}

export default App;

        </code>
    </pre>

    <div class="code-info">
        <h2><strong>useMemo Hook</strong></h2>
        <ul class="code-list">
            <li>이전에 연산된 값을 재사용(성능최적화에 사용)</li>
            <li>useMemo : 특정 값이 바뀌었을 때만, 특정 함수를 실행해서, 연산을 하도록 처리</li>
            <li><a href="\tutorial\begin-react\src\app.js" target="_blank">재사용 연산</a></li>
        </ul>
    </div>
    <pre>
        <code>
import React, { useRef, useState, useMemo } from 'react';
import UserList5 from './UserList5';
import CreateUser from './CreateUser';

//useMemo hook
function countActiveUsers(users) {
    console.log('활성 사용자 수를 세는중...');
    return users.filter(user => user.active).length;
}


function App() {
    //createUser에서 필요한 props 준비
    const [inputs, setInputs] = useState({
    username : '',
    email : '',
    });

    const { username, email } = inputs;
    const onChange = (e) => {
    const { name, value } = e.target;
    setInputs({
        ...inputs,
        [name] : value
    });
    };

    // 배열을 컴포넌트의 상태로 관리해주는법 
    const [users, setUsers] = useState([
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com',
        active : true,
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com',
        active : false,
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com',
        active : false,
    }
    ]);


    const nextId = useRef(4);
    
    // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
    const onCreate = () => {
    //push splice sort 사용 X
    // 배열의 불변성 지키면서 새로운 항목 추가하는 법
    // 1.배열에서 spread 연산자 쓰기
    // 새로운 user 객체 만들기
    const user = {
        id : nextId.current,
        username,
        email,
    }; 
    setUsers(
        [...users, user] //spread
    ); 
    setUsers(
        // [...users, user] spread
        users.concat(user) //concat 함수
    ); //기존 배열 복사해서 넣으면서 새항목 추가
    // 2. concat함수 쓰기
    setInputs({
        username : '',
        email : ''
    });
    console.log(nextId.current); // 4
    nextId.current += 1;
    };


    // remove
    const onRemove = id => { //파라미터로 받아온 아이디랑 비교
    setUsers(users.filter(user => user.id !== id));
    };

    // onToggle : 유저가 가지고 있던 값을 가져오고, 특정 값을 덮어 씌우는 방법
    const onToggle = id => {
    //불변성 지키면서 배열 업데이트 할 때, map 사용
    setUsers(users.map(
        user => user.id === id 
        ? { ...user, active : !user.active }
        : user
    ));
    };
    // UseMemo : 첫번째 파라미터는 함수, 두번째 파라미터 deps
    const count = useMemo(() => countActiveUsers(users),[users]);


    return (
    &lt;&gt;
        &lt;CreateUser 
        username={username} 
        email={email} 
        onChange={onChange} 
        onCreate={onCreate}
        /&gt;
        &lt;UserList5 
        users={users} 
        onRemove={onRemove} 
        onToggle={onToggle}
        /&gt;
        &lt;div&gt;활성 사용자 수: {count}&lt;/div&gt;
    &lt;/&gt;
    
    );
}

export default App;
            
        </code>
    </pre>

    <div class="code-info">
        <h2><strong>useCallback Hook</strong></h2>
        <ul class="code-list">
            <li>useCallback : 이전에 만들었던 함수 재사용, 함수를 위한 Hook, useMemo와 마찬가지로 deps도 넣어줘야함</li>
        </ul>
    </div>
    <pre>
        <code>
import React, { useRef, useState, useMemo, useCallback } from 'react';
import UserList5 from './UserList5';
import CreateUser from './CreateUser';

//useMemo hook
function countActiveUsers(users) {
    console.log('활성 사용자 수를 세는중...');
    return users.filter(user => user.active).length;
}


function App() {
    //createUser에서 필요한 props 준비
    const [inputs, setInputs] = useState({
    username : '',
    email : '',
    });

    const { username, email } = inputs;
    const onChange = useCallback((e) => { //onChange 함수는 inputs가 바뀔때만 생성이됨
    const { name, value } = e.target;
    setInputs({
        ...inputs,
        [name] : value
    });
    }, [inputs]);

    // 배열을 컴포넌트의 상태로 관리해주는법 
    const [users, setUsers] = useState([
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com',
        active : true,
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com',
        active : false,
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com',
        active : false,
    }
    ]);


    const nextId = useRef(4);
    
    // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
    const onCreate = useCallback(() => {
    //push splice sort 사용 X
    // 배열의 불변성 지키면서 새로운 항목 추가하는 법
    // 1.배열에서 spread 연산자 쓰기
    // 새로운 user 객체 만들기
    const user = {
        id : nextId.current,
        username,
        email,
    }; 
    setUsers(
        [...users, user] //spread
    ); 
    setUsers(
        // [...users, user] spread
        users.concat(user) //concat 함수
    ); //기존 배열 복사해서 넣으면서 새항목 추가
    // 2. concat함수 쓰기
    setInputs({
        username : '',
        email : ''
    });
    console.log(nextId.current); // 4
    nextId.current += 1;
    }, [username, email, users]);


    // remove
    const onRemove = useCallback(id => { //파라미터로 받아온 아이디랑 비교
    setUsers(users.filter(user => user.id !== id));
    }, [users]);

    // onToggle : 유저가 가지고 있던 값을 가져오고, 특정 값을 덮어 씌우는 방법
    const onToggle = useCallback(id => {
    //불변성 지키면서 배열 업데이트 할 때, map 사용
    setUsers(users.map(
        user => user.id === id 
        ? { ...user, active : !user.active }
        : user
    ));
    }, [users]);
    // UseMemo : 첫번째 파라미터는 함수, 두번째 파라미터 deps
    const count = useMemo(() => countActiveUsers(users),[users]);

    return (
    &lt;&gt;

        &lt;CreateUser 
        username={username} 
        email={email} 
        onChange={onChange} 
        onCreate={onCreate}
        /&gt;

        &lt;UserList5 
        users={users} 
        onRemove={onRemove} 
        onToggle={onToggle}
        /&gt;
        &lt;div&gt;활성 사용자 수: {count}&lt;/div&gt; 
    &lt;/&gt;
    
    );
}

export default App;
            
        </code>
    </pre>

    <div class="code-info">
        <h2><strong>React.memo 리랜더링 방지</strong></h2>
        <ul class="code-list">
            <li>컴포넌트에서 리랜더링이 불필요할 때, 전에 사용했던것을 재사용 할 수 있게 함</li>
            <li>props가 바뀌었을때만 리랜더링 됨 => React.memo(CreateUser)</li>
            <li>UserList5.js의 user부분은 const User = React.memo() 로 감싸주기</li>
            <li>이렇게하면 input의 값을 넣을 때마다 리랜더링 됬던 것들의 아래있는것들에 영향을 받지 않음</li>
            <li>users 배열이 바뀌면 onToggle, onRemove 도 바뀌니까 내부의것들을 다 리랜더링을 해야하는데, 이것을 해결하려면 함수들에 uers를 참조하지않고, useState의 함수형 업데이트를 한다</li>
            <li>최적화를 할 수 있는 함수만 최적화를 한다</li>
            <li><a href="tutorial\begin-react\src\UserList5.js" target="_blank">리랜더링 MEMO</a></li>
        </ul>
    </div>
    <pre>
        <code>
import React, { useEffect } from 'react';
//user map
const User = React.memo(function User({ user, onRemove, onToggle }) { //onRemove 받아오기
    //추출
    const { username, email, id, active } = user;
    console.log(user);
    // 첫번째 파라미터 = 실행하고픈 함수, deps
    /*
    useEffect(() => {
        console.log('컴포넌트가 화면에 나타납니다.');
        // 마운트 될 때 추가하는작업
        // props => state 설정
        // REST API
        // D3 Video.js 사용시
        // setInterval, setTimeout
        return () => {
            console.log('컴포넌트가 화면에서 사라졌습니다.');
            // 언마운트 될 때 추가하는 작업 
            // clearInterval, clearTimeout
            // 라이브러리 인스턴스 제거
        }
    }, []);// 배열 deps(props, 상태)
    */
    /* 
    useEffect(() => { //마운트 될때도 user값이 나타남
        console.log('user값이 설정됨');
        console.log(user);
        return () => {// 뒷정리 함수
            console.log('user값이 바뀌기 전');
            console.log(user);
        }
    }, [user]);
    */
    
    useEffect(() =&gt; { //하나를 눌러도 모든 컴포넌트에서 호출됨
        console.log(user);
    })
    /* 실 사용 예시
    useEffect(() =&gt; {
        loadPost(username, urlSlug);
    }, [username, urlSlug]);
    */
    return (
        &lt;div&gt;
            &lt;b style={{
                    color : active ? 'green' : 'black',
                    cursor : 'pointer'
                }}
                onClick={() =&gt;onToggle(id)}
            &gt;
                {/* {users[0].username} */}
                {/* {user.username} */}
                {username}
            &lt;/b&gt;
            &nbsp;
            &lt;span&gt;
                ({email})
            &lt;/span&gt;
            &lt;button onClick={()=&gt;onRemove(id)}&gt;
            {/* 함수를 새로 만들어서 호출 */}
                {/* 버튼이 눌렀을때는 prop를 id값을 넣어서 호출할꺼다 */}
                삭제 
            &lt;/button&gt;
        &lt;/div&gt;
    );
});


function UserList5({ users, onRemove, onToggle }) {//삭제하는 props
    //user를 props로 받아오게끔
    return (
        &lt;div&gt;
            {
                users.map(
                    (user, index) =&gt; (
                        &lt;User user={user} 
                        key={user.id} 
                        onRemove={onRemove} 
                        onToggle={onToggle}
                    /&gt;
                )
            )
            }
        &lt;/div&gt;
    )
};

export default React.memo(
    UserList5, 
    (prevProps, nextProps) => nextProps.users === prevProps.users
    // 나머지 prop가 고정적이어서 업데이트 할 필요 없는건지 확인
);


// app.js
import React, { useRef, useState, useMemo, useCallback } from 'react';
import UserList5 from './UserList5';
import CreateUser from './CreateUser';

//useMemo hook
function countActiveUsers(users) {
  console.log('활성 사용자 수를 세는중...');
  return users.filter(user => user.active).length;
}


function App() {
  //createUser에서 필요한 props 준비
  const [inputs, setInputs] = useState({
    username : '',
    email : '',
  });

  const { username, email } = inputs;
  const onChange = useCallback((e) => { //onChange 함수는 inputs가 바뀔때만 생성이됨
    const { name, value } = e.target;
    setInputs({
      ...inputs,
      [name] : value
    });
  }, [inputs]);

  // 배열을 컴포넌트의 상태로 관리해주는법 
  const [users, setUsers] = useState([
    {
        id : 1,
        username : 'velopert',
        email : 'public.vepopert@gmail.com',
        active : true,
    },
    {
        id : 2,
        username : 'tester',
        email : 'tester@example.com',
        active : false,
    },
    {
        id : 3,
        username : 'liz',
        email : 'liz@example.com',
        active : false,
    }
  ]);


  const nextId = useRef(4);
  
  // 값이 바뀔 때 리랜더링 할 필요가 없기 때문에 useRef로 관리
  const onCreate = useCallback(() => {
    //push splice sort 사용 X
    // 배열의 불변성 지키면서 새로운 항목 추가하는 법
    // 1.배열에서 spread 연산자 쓰기
    // 새로운 user 객체 만들기
    const user = {
      id : nextId.current,
      username,
      email,
    }; 
    // setUsers(
    //   [...users, user] //spread
    // ); 
    setUsers(
      // [...users, user] spread
      users => users.concat(user) //concat 함수를 userState처럼 즉시실행하면
    ); //기존 배열 복사해서 넣으면서 새항목 추가
    // 2. concat함수 쓰기
    setInputs({
      username : '',
      email : ''
    });
    console.log(nextId.current); // 4
    nextId.current += 1;
  }, [username, email]); //username, email만 바뀔때 새로 만들어진다


  // remove
  const onRemove = useCallback(id => { //파라미터로 받아온 아이디랑 비교
    setUsers(uesrs => users.filter(user => user.id !== id));
  }, []);

  // onToggle : 유저가 가지고 있던 값을 가져오고, 특정 값을 덮어 씌우는 방법
  const onToggle = useCallback(id => {
    //불변성 지키면서 배열 업데이트 할 때, map 사용
    setUsers( users => users.map(
      user => user.id === id 
      ? { ...user, active : !user.active }
      : user
    ));
  }, []);
  // UseMemo : 첫번째 파라미터는 함수, 두번째 파라미터 deps
  const count = useMemo(() => countActiveUsers(users),[users]);


  return (
    &lt;&gt;
        &lt;CreateUser 
            username={username} 
            email={email} 
            onChange={onChange} 
            onCreate={onCreate}
        /&gt;
        
      &lt;UserList5 
        users={users} 
        onRemove={onRemove} 
        onToggle={onToggle}
      /&gt;
    &lt;div&gt;활성 사용자 수: {count}&lt;/div&gt;
    &lt;/&gt;
   
  );
}

export default App;

        </code>
    </pre>

    <div class="code-info">
        <h2><strong>useReducer Hook</strong></h2>
        <ul class="code-list">
            <li>액션(업데이트할 때 참조하는) 이라는 객체를 기반으로 상태 업데이트</li>
            <li>상태 업데이트 로직을 컴포넌트 밖으로 분리 가능</li>
            <li>reducer : 상태를 업데이트 하는 함수</li>
            <li><a href="tutorial\begin-react\src\Counter1.js">상태 업데이트</a></li>
            <li><a href="tutorial\begin-react\src\App.js">상태 업데이트 reducer</a></li>
            <li>숫자, 문자, 불리언 값 같은 딱 하나의 컴포넌트 값을 관리할 때는 useState가 편하다.</li>
            <li>
                setter함수를 여러번 사용할 때 여러번 반복되고 추가, 생략된다면 useReducer가 편하다.<br><br>
                setUsers(users=> users.concat(user));<br>
                setInputs({<br>
                    &nbsp;&nbsp;username: '',<br>
                    &nbsp;&nbsp;email: ''<br>
                });
            </li>
        </ul>
    </div>
    <pre>
        <code>
//reducer 
function reducer(state, action) { //현재상태 ,액션객체 
    switch(action.type){
        case 'INCREMENT':
            return state + 1;
        case 'DECREMENT':
            return state -1;;
        default:
            return state;
    }
}

const [number, dispatch] = useReducer(reducer, 0); // 함수, 기본값(숫자, 문자, 객체, 배열)
//number : 현재상태
//dispatch : 액션을 발생 시키는 함수


// Counter1.js
import React, { useReducer } from 'react';

function reducer(state, action) {
//state : 값의 타입은 뭐든지 가능, 숫자, 문자, 객체, 배열    
    switch(action.type){
        case 'INCREMENT':
            return state + 1;
        case 'DECREMENT':
            return state - 1;
        default:
            // return state;
            throw new Error('Unhandled action');
    }
}

function Counter1() {
    const [number, dispatch] = useReducer(reducer, 0); //reducer, 초기값

    const onIncrease = () => {
        dispatch({
            type: 'INCREMENT'
        })
    }

    const onDecrease = () => {
        dispatch({
            type: 'DECREMENT'
        })
    }

    return (
        &lt;div&gt;
            &lt;h1&gt;{number}&lt;/h1&gt;
            &lt;button onClick={onIncrease}&gt;+1&lt;/button&gt;
            &lt;button onClick={onDecrease}&gt;-1&lt;/button&gt;
        &lt;/div&gt;
    )
};

export default Counter1;


// App.js
import React, { useRef, useState, useMemo, useCallback } from 'react';
import Counter1 from './Counter1';


  return (
    &lt;&gt;
        &lt;Counter1 /&gt;
    &lt;/&gt;
   
  );
}

export default App;

        </code>
    </pre>
    <br>
    <pre>
        <code>
// app.js
import React, { useRef,  useReducer, useMemo, useCallback } from 'react';
import UserList5 from './UserList5';
import CreateUser from './CreateUser';



//사용자 카운트
function countActiveUsers(users) {
    console.log('활성 사용자 수를 세는중...');
    return users.filter(user => user.active).length;
    }
    

// useReducer 구현하기 
const initialState = {
    inputs: {
        username : '',
        email : '',
    },
    users : [
        {
            id : 1,
            username : 'velopert',
            email : 'public.vepopert@gmail.com',
            active : true,
        },
        {
            id : 2,
            username : 'tester',
            email : 'tester@example.com',
            active : false,
        },
        {
            id : 3,
            username : 'liz',
            email : 'liz@example.com',
            active : false,
        }
    ]
};

// reducer 함수의 틀 만들기
function reducer(state, action) {
    switch (action.type) {
        case 'CHANGE_INPUT' :
            return {
                ...state,
                inputs : {
                    ...state.inputs,
                    [action.name] : action.value
            }   
        };
        case 'CREATE_USER' :
            return {
                inputs : initialState.inputs,
                users : state.users.concat(action.user)
            }
        case 'TOGGLE_USER' :
            return {
                ...state,
                users : state.users.map( user => 
                    user.id === action.id 
                    ? {...user, active: !user.active}
                    : user
                )
            };
        case 'REMOVE_USER' : 
            return {
                ...state,
                users : state.users.filter(user => user.id !== action.id)
            }
        default : 
            // return state;
            throw new Error('Unhandled action');
    }
}

function App() {
    //현재상태, action발생시키는 함수
    const [state, dispatch] = useReducer(reducer, initialState);
    const nextId = useRef(4);
    const { users } = state;
    const { username, email } = state.inputs;

    const onChange = useCallback(e => {
        const { name, value } = e.target; // e.target에서 추출
        dispatch({
            type : 'CHANGE_INPUT',
            name,
            value,
        })
    }, []);

    const onCreate = useCallback(() => {
        dispatch({
            type : 'CREATE_USER',
            user : {
                id : nextId.current,
                username,
                email,
            }
        });
        nextId.current += 1;
    }, [username, email]);

    const onToggle = useCallback(id => {
        dispatch({
            type : 'TOGGLE_USER',
            id
        });
    }, []);

    const onRemove = useCallback(id => {
        dispatch({
            type : 'REMOVE_USER',
            id
        }, []);
    });
    
    const count = useMemo(() => countActiveUsers(users), [users]);
    return (
        &lt;&gt;
            &lt;CreateUser 
                username={username} 
                email={email} 
                onChange={onChange}
                onCreate={onCreate}
            /&gt;
            &lt;UserList5 
                users={users} 
                onToggle={onToggle} 
                onRemove={onRemove}
            /&gt;
            &lt;div&gt;활성 사용자 수: {count}&lt;/div&gt; 
        &lt;/&gt;
    
    );
}

export default App;
            
        </code>
    </pre>

    <div class="code-info">
        <h2><strong>Custom Hook 만들기</strong></h2>
        <ul class="code-list">
            <li>
                const onChange = (e) => {<br>
                    &nbsp;&nbsp;const { name, value } = e.target;<br>
                    &nbsp;&nbsp;setInputs({ ...inputs, [name] : value });<br>
                }
            </li>
            <li>input 상태를 관리할 때 쓰임</li>
        </ul>
    </div>
    <pre>
        <code>
        </code>
    </pre>
<!-- 
    <div class="code-info">
        <h2><strong></strong></h2>
        <ul class="code-list">
            <li></li>
        </ul>
    </div>
    <pre>
        <code>
        </code>
    </pre>
-->

    </div>
</body>
</html>
